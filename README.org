#+TITLE: Best practices for A* on grids
#+OPTIONS: toc:3 author:t creator:nil num:nil
#+AUTHOR: Chris Rayner
#+EMAIL: dchrisrayner@gmail.com

[[file:img/grid.png]]
# http://www.veryicon.com/icons/system/icons8-metro-style/timeline-list-grid-grid.html

* Table of Contents :TOC_3_gh:noexport:
 - [[#description][Description]]
     - [[#contributing][Contributing]]
 - [[#preliminaries][Preliminaries]]
 - [[#implement-the-open-list-using-a-heap][Implement the open list using a heap]]
 - [[#avoid-floating-point-arithmetic][Avoid floating point arithmetic]]
 - [[#use-a-non-overestimating-heuristic][Use a non-overestimating heuristic]]
     - [[#on-a-4-connected-grid][On a 4-connected grid]]
     - [[#on-an-8-connected-grid][On an 8-connected grid]]
 - [[#modified-move-costs][Modified move costs]]
     - [[#diagonal-99cardinal-70][Diagonal: 99/Cardinal: 70]]
     - [[#diagonal-3cardinal-2][Diagonal: 3/Cardinal: 2]]
     - [[#diagonal-99cardinal-50][Diagonal: 99/Cardinal: 50]]
 - [[#resources][Resources]]

* Description
  Here are some simple notes on ways to improve A*, focusing on four- and
  eight-connected gridworlds.  This document is pitched at hobbyists and anyone
  looking for ideas on how to make an existing implementation a bit faster.

  Check out the [[https://github.com/riscy/a_star_on_grids/tree/master/src][src]] directory for some example code in C++.
*** Contributing
    If you have any (much appreciated) corrections or contributions, feel free
    to get in touch or to simply make a pull request.
* Preliminaries
  Skip this if you're very familiar with A*.  If you're not, you might want to check
  out the [[#resources][resources]] section.

  Forgoing a complete description of A*, recall that A* is essentially a loop
  that expands a list of /open/ states that reach toward the goal.  Each
  iteration expands the /open list/ with the neighbors of an already open
  state.  The open state ~i~ that gets chosen is one with the lowest ~f~ cost,
  #+begin_src ruby
  f_i(s,g) = g(s,i) + h(i,g)
  #+end_src

  This ~f~ cost is an estimate of the cost of an optimal path between ~s~ and
  ~g~ that goes through ~i~.  Here ~g(s,i)~ is the /ground truth/ distance to
  get from the start state ~s~ to open state ~i~ (the value of which A*
  knows exactly).  ~h(i,g)~ is a cheaply computed heuristic estimate for the
  distance from ~i~ to the goal state ~g~.
* Implement the open list using a heap
  ...and implement the heap using an array.  [[https://github.com/riscy/a_star_on_grids/blob/master/src/node_heap.h][Example code]].

  Depending on the implementation language, this isn't as important for small
  maps (on the order of a couple thousand cells).  On larger maps, this can cut
  execution time in half.

  Note it is common for multiple states on the open list have the lowest ~f~
  cost, so there is an opportunity to add [[https://github.com/riscy/a_star_on_grids/blob/master/src/node_heap.h#L9][smart tie-breaking]] on larger ~g~
  values.  This makes A* focus on deep solutions rather than a breadth of
  shallow solutions.  A video example of this can be viewed on [[http://movingai.com/astar.html][Nathan
  Sturtevant's movingai.com]].
* Avoid floating point arithmetic
  Prefer integral data types wherever possible.  This is not only faster but
  helps to avoid the numerical imprecision that can confuse debugging attempts.
* Use a non-overestimating heuristic
  Heuristics that don't overestimate are called /admissible/.  A* recovers an optimal
  path when it's using an admissible heuristic.  A good, admissible gridworld
  heuristic is the distance between two cells assuming no obstacles.
*** On a 4-connected grid
    The distance between two cells on a 4-connected grid, assuming no obstacles,
    is the *rectilinear* (or *L1-norm* or *Manhattan*) distance:
    #+begin_src ruby
    h(i,j) = C * (Δx + Δy)
    #+end_src
    where ~Δx~ and ~Δy~ are absolute distances between grid cells along the
    ~x~ and ~y~ axes and ~C~ is the cost to take a cardinal move.
*** On an 8-connected grid
    When pathfinding on an 8-connected grid, use the *octile heuristic*:
    #+begin_src ruby
    h(i, j) = C * Δx + B * Δy   if Δx > Δy
              C * Δy + B * Δx   else
    #+end_src 
    where ~B = D - C~ with ~C~ being the cost to take a cardinal move and ~D~
    being the cost to take a diagonal move.  [[https://github.com/riscy/a_star_on_grids/blob/master/src/heuristics.cpp#L54][Example code]].
  
    Note the octile heuristic can be written without a conditional (albeit with an
    absolute value), which may help improve instruction level parallelism:
    #+begin_src ruby
    h(i, j) = (E * abs(Δx - Δy) + D * (Δx + Δy)) / 2
    #+end_src
    where ~E = 2 * C - D~.  You can see how to simplify this further if both ~D~
    and ~E~ are even numbers.  [[https://github.com/riscy/a_star_on_grids/blob/master/src/heuristics.cpp#L62][Example code]].
    # A proof for this relies on using a 45-degree rotation matrix to
    # turn what is effectively a norm in Linfty into a norm in L1 space.
* Modified move costs
  On an 8-connected grid, the cost of a diagonal move (~D~) relative to the cost of a cardinal
  move (~C~) affects the appearance of the resulting paths.  If a diagonal move costs
  /less/ than a cardinal move, A* prefers zig-zagging paths.  If a diagonal move
  costs more than /two/ cardinal moves, A* prefers rectilinear paths.

  Paths tend to look best when the costs lie between these two extremes, but
  some algorithms (like Fringe Search) are hugely sensitive to changes in cost
  structure.  You might try one of the following.
*** Diagonal: 99/Cardinal: 70
    If you prefer a diagonal move to cost ~sqrt(2)~ relative to a
    cardinal move, try using ~D = 99~ for the cost of a diagonal move and ~C = 70~ for
    the cost of a cardinal move.  This close approximation helps to avoid
    floating point arithmetic.
*** Diagonal: 3/Cardinal: 2
    If your heuristic can return fractional values, ~D = 3/C = 2~ gives you the
    ability to take the /ceiling/ of those fractional heuristics since all
    distances must be integral.  This is still reasonably close to a ~D/C~ ratio
    of ~sqrt(2)~, and again you avoid floating point arithmetic.

    My Ph.D. co-supervisor Nathan Sturtevant showed me this when we wrote
    [[http://www.aaai.org/ocs/index.php/AAAI/AAAI11/paper/viewFile/3594/3821][Euclidean Heuristic Optimization]] (Rayner, Bowling, Sturtevant), and it made
    a noticeable difference.
*** Diagonal: 99/Cardinal: 50
    ~D = 99/C = 50~ gives something very close to a rectilinear cost structure.
    On average this can keep the size of the open list smaller, but it can also
    increase node expansions, depending on the layout of the grid.  This can be
    beneficial in many cases, but you should test it out before you use it.
* Resources
  Additional resources that might also be helpful:
  - [[http://www.policyalmanac.org/games/aStarTutorial.htm][Patrick Lester's A* for beginners]] :: This is a good starting point for learning
       A*.
  - [[https://en.wikipedia.org/wiki/A*_search_algorithm][A* on Wikipedia]] :: Wikipedia gives a thorough description of A*.
  - [[http://movingai.com][Nathan Sturtevant's movingai.com]] :: Benchmark problems and videos covering
       some advanced topics.
  - [[http://www.roguebasin.com/index.php?title=The_Incredible_Power_of_Dijkstra_Maps][Dijkstra Maps]] :: Dijkstra Maps are also known as "differential heuristics",
       "ALT heuristics", or "Lipschitz embeddings".  We looked at smart ways to
       set these heuristics up in [[https://webdocs.cs.ualberta.ca/~bowling/papers/13ijcai-hsubset.pdf][Subset Selection of Search Heuristics]] (Rayner,
       Sturtevant, Bowling) but this article describes some extremely novel ways
       to use these mappings to control game entities.
